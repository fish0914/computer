<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>二階段進化：俄羅斯方塊與索瑪</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; touch-action: none; background-color: #1a1a1a; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #game-container { position: relative; width: 100vw; height: 100vh; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; color: white; z-index: 50; }
        .hidden { display: none !important; }
        .btn-control {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            user-select: none;
            touch-action: manipulation;
        }
        .btn-control:active { background: rgba(255, 255, 255, 0.3); }
        .btn-camera {
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            width: 40px;
            height: 40px;
            font-size: 16px;
        }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #controls-layer, #camera-controls { pointer-events: auto; }
        /* Glowing text effect */
        .neon-text { text-shadow: 0 0 10px #4ade80, 0 0 20px #4ade80; }
    </style>
</head>
<body>

<div id="game-container">
    <!-- UI Layer -->
    <div id="ui-layer" class="flex flex-col justify-between p-4 z-10">
        <!-- Top HUD -->
        <div class="flex justify-between items-start w-full">
            <div class="bg-gray-900 bg-opacity-80 p-4 rounded-lg border border-gray-700 pointer-events-auto">
                <h1 class="text-xl font-bold text-green-400 mb-1">LEVEL <span id="level-display">1</span></h1>
                <p class="text-gray-300 text-sm mb-1">目標: <span id="goal-text">消除 2 行</span></p>
                <p class="text-white text-lg font-mono">SCORE: <span id="score-display">0</span></p>
            </div>
            
            <!-- Camera Controls (Visible in Level 2) -->
            <div id="camera-controls" class="hidden flex flex-col items-center bg-gray-900 bg-opacity-80 p-2 rounded-lg border border-blue-900">
                <p class="text-xs text-blue-300 mb-1">視角 (WASD)</p>
                <button id="cam-up" class="btn-control btn-camera mb-1">↑</button>
                <div class="flex gap-1 mb-1">
                    <button id="cam-left" class="btn-control btn-camera">←</button>
                    <button id="cam-right" class="btn-control btn-camera">→</button>
                </div>
                <button id="cam-down" class="btn-control btn-camera">↓</button>
            </div>
        </div>
        
        <!-- Bottom Controls -->
        <div id="controls-layer" class="w-full pb-8 md:hidden flex flex-col gap-4">
            <div class="flex justify-between px-4">
                <div class="flex gap-4">
                    <button id="btn-left" class="btn-control">←</button>
                    <button id="btn-right" class="btn-control">→</button>
                </div>
                <!-- 3D extra movement -->
                <div id="3d-controls-extra" class="flex gap-2 hidden">
                     <button id="btn-up-key" class="btn-control text-yellow-300">前後</button>
                     <button id="btn-down-key" class="btn-control text-yellow-300">前後</button>
                </div>
                <div class="flex gap-4">
                    <button id="btn-rotate" class="btn-control">↻</button>
                    <button id="btn-down" class="btn-control">↓</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Game Canvas Placeholder -->
    <div id="canvas-wrapper" class="absolute inset-0 flex justify-center align-middle z-0 bg-gray-900">
        <!-- Canvas/ThreeJS will be injected here -->
    </div>

    <!-- Start Overlay -->
    <div id="start-overlay" class="overlay">
        <h1 class="text-5xl font-black mb-4 tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-blue-500 neon-text">TETRIS EVOLUTION</h1>
        <p class="mb-6 text-gray-300 text-center max-w-md px-4">硬核挑戰版</p>
        
        <div class="bg-gray-800 bg-opacity-90 p-6 rounded-xl border border-gray-600 mb-8 max-w-md text-left text-sm space-y-3">
            <div>
                <strong class="text-green-400 text-lg">第一關 (2D)</strong>
                <p class="text-gray-300">目標：消除 <span class="text-white font-bold">2 行</span></p>
            </div>
            <div class="border-t border-gray-600 pt-3">
                <strong class="text-blue-400 text-lg">第二關 (3D 索瑪)</strong>
                <p class="text-gray-300">目標：消除 <span class="text-white font-bold">3 層</span> 平面</p>
                <ul class="list-disc list-inside text-gray-400 mt-1 space-y-1">
                    <li>只有 7 種經典形狀，無填充方塊！</li>
                    <li>任何空洞都可能導致該層無法消除。</li>
                    <li>使用右上角或 WASD 旋轉視角觀察。</li>
                </ul>
            </div>
        </div>

        <button id="start-btn" class="px-8 py-4 bg-green-600 hover:bg-green-500 text-white font-bold rounded-full text-xl transition transform hover:scale-105 shadow-lg shadow-green-500/50">
            接受挑戰
        </button>
    </div>

    <!-- Game Over Overlay -->
    <div id="game-over-overlay" class="overlay hidden">
        <h1 class="text-4xl font-bold text-red-500 mb-2">GAME OVER</h1>
        <p class="text-xl text-white mb-6">最終分數: <span id="final-score">0</span></p>
        <button id="restart-btn" class="px-6 py-3 bg-white text-black font-bold rounded hover:bg-gray-200 transition">
            重新生成
        </button>
    </div>

    <!-- Victory Overlay -->
    <div id="victory-overlay" class="overlay hidden">
        <h1 class="text-5xl font-black text-yellow-400 mb-4 neon-text">VICTORY!</h1>
        <p class="text-2xl text-white mb-2">挑戰成功</p>
        <p class="text-gray-300 mb-8">你克服了索瑪方塊的幾何難題。</p>
        <p class="text-xl text-white mb-6">最終分數: <span id="victory-score">0</span></p>
        <button id="restart-btn-v" class="px-6 py-3 bg-green-500 text-white font-bold rounded hover:bg-green-600 transition">
            再次挑戰
        </button>
    </div>

    <!-- Level Up Overlay -->
    <div id="level-up-overlay" class="overlay hidden">
        <h1 class="text-4xl font-bold text-yellow-400 mb-2 neon-text">LEVEL 1 CLEAR!</h1>
        <p class="text-xl text-white mb-6">啟動 3D 引擎...</p>
        <p class="text-sm text-blue-300">注意：進入 3D 索瑪模式 (經典 7 塊)</p>
    </div>
</div>

<script>
/**
 * 遊戲生成王 - Evolution Code
 */

// --- 全局變數 ---
let currentState = 'MENU'; 
let currentLevel = 1;
let score = 0;
let linesClearedTotal = 0;
let l2_linesCleared = 0;
let animationFrameId;

// DOM Elements
const canvasWrapper = document.getElementById('canvas-wrapper');
const scoreDisplay = document.getElementById('score-display');
const levelDisplay = document.getElementById('level-display');
const goalText = document.getElementById('goal-text');
const startOverlay = document.getElementById('start-overlay');
const gameOverOverlay = document.getElementById('game-over-overlay');
const victoryOverlay = document.getElementById('victory-overlay');
const levelUpOverlay = document.getElementById('level-up-overlay');
const cameraControls = document.getElementById('camera-controls');
const extraControls3D = document.getElementById('3d-controls-extra');

// --- LEVEL 1: 2D TETRIS ---
const L1_COLS = 10;
const L1_ROWS = 20;
const L1_BLOCK_SIZE = 30;
const L1_GOAL = 2; 
let l1_canvas, l1_ctx;
let l1_board = [];
let l1_piece = null;

const L1_SHAPES = [
    [],
    [[1, 1, 1, 1]], 
    [[1, 1, 1], [0, 0, 1]], 
    [[1, 1, 1], [1, 0, 0]], 
    [[1, 1], [1, 1]], 
    [[0, 1, 1], [1, 1, 0]], 
    [[1, 1, 1], [0, 1, 0]], 
    [[1, 1, 0], [0, 1, 1]] 
];
const L1_COLORS = [null, '#06b6d4', '#3b82f6', '#f97316', '#eab308', '#22c55e', '#a855f7', '#ef4444'];

function initLevel1() {
    canvasWrapper.innerHTML = '';
    l1_canvas = document.createElement('canvas');
    l1_canvas.width = L1_COLS * L1_BLOCK_SIZE;
    l1_canvas.height = L1_ROWS * L1_BLOCK_SIZE;
    l1_canvas.style.border = '2px solid #333';
    l1_canvas.style.backgroundColor = '#000';
    canvasWrapper.appendChild(l1_canvas);
    l1_ctx = l1_canvas.getContext('2d');

    l1_board = Array.from({length: L1_ROWS}, () => Array(L1_COLS).fill(0));
    linesClearedTotal = 0;
    
    // UI Reset
    levelDisplay.innerText = "1";
    goalText.innerText = `消除 ${L1_GOAL} 行`;
    scoreDisplay.innerText = score;
    cameraControls.classList.add('hidden');
    extraControls3D.classList.add('hidden');

    spawnL1Piece();
    lastTime = 0;
    dropCounter = 0;
    currentState = 'PLAYING';
    requestAnimationFrame(l1_update);
}

function spawnL1Piece() {
    const id = Math.ceil(Math.random() * 7);
    const shape = L1_SHAPES[id];
    l1_piece = {
        id: id,
        shape: shape,
        x: Math.floor(L1_COLS / 2) - Math.floor(shape[0].length / 2),
        y: 0
    };
    if (l1_collide(l1_board, l1_piece)) gameOver();
}

function l1_collide(board, piece) {
    const m = piece.shape;
    const o = piece;
    for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
            if (m[y][x] !== 0 && (board[y + o.y] && board[y + o.y][x + o.x]) !== 0) return true;
        }
    }
    return false;
}

function l1_rotate(matrix) {
    for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
            [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
    }
    matrix.forEach(row => row.reverse());
}

function l1_merge(board, piece) {
    piece.shape.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) board[y + piece.y][x + piece.x] = piece.id;
        });
    });
}

function l1_sweep() {
    let rowCount = 0;
    outer: for (let y = L1_ROWS - 1; y >= 0; --y) {
        for (let x = 0; x < L1_COLS; ++x) {
            if (l1_board[y][x] === 0) continue outer;
        }
        const row = l1_board.splice(y, 1)[0].fill(0);
        l1_board.unshift(row);
        ++y;
        rowCount++;
        linesClearedTotal++;
    }
    if (rowCount > 0) {
        score += rowCount * 100;
        scoreDisplay.innerText = score;
        goalText.innerText = `剩餘 ${Math.max(0, L1_GOAL - linesClearedTotal)} 行`;
        if (linesClearedTotal >= L1_GOAL) advanceToLevel2();
    }
}

let lastTime = 0;
let dropCounter = 0;
let dropInterval = 1000;

function l1_update(time = 0) {
    if (currentState !== 'PLAYING' || currentLevel !== 1) return;
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if (dropCounter > dropInterval) l1_playerDrop();
    l1_draw();
    animationFrameId = requestAnimationFrame(l1_update);
}

function l1_playerDrop() {
    l1_piece.y++;
    if (l1_collide(l1_board, l1_piece)) {
        l1_piece.y--;
        l1_merge(l1_board, l1_piece);
        l1_sweep();
        spawnL1Piece();
    }
    dropCounter = 0;
}

function l1_playerMove(dir) {
    l1_piece.x += dir;
    if (l1_collide(l1_board, l1_piece)) l1_piece.x -= dir;
}

function l1_playerRotate() {
    const pos = l1_piece.x;
    let offset = 1;
    l1_rotate(l1_piece.shape);
    while (l1_collide(l1_board, l1_piece)) {
        l1_piece.x += offset;
        offset = -(offset + (offset > 0 ? 1 : -1));
        if (offset > l1_piece.shape[0].length) {
            l1_rotate(l1_piece.shape); l1_rotate(l1_piece.shape); l1_rotate(l1_piece.shape);
            l1_piece.x = pos;
            return;
        }
    }
}

function l1_draw() {
    l1_ctx.fillStyle = '#000';
    l1_ctx.fillRect(0, 0, l1_canvas.width, l1_canvas.height);
    l1_drawMatrix(l1_board, {x: 0, y: 0});
    l1_drawMatrix(l1_piece.shape, l1_piece);
}

function l1_drawMatrix(matrix, offset) {
    matrix.forEach((row, y) => {
        row.forEach((value, x) => {
            if (value !== 0) {
                l1_ctx.fillStyle = L1_COLORS[value];
                l1_ctx.fillRect((x + offset.x) * L1_BLOCK_SIZE, (y + offset.y) * L1_BLOCK_SIZE, L1_BLOCK_SIZE - 1, L1_BLOCK_SIZE - 1);
                l1_ctx.strokeStyle = 'white';
                l1_ctx.lineWidth = 0.5;
                l1_ctx.strokeRect((x + offset.x) * L1_BLOCK_SIZE, (y + offset.y) * L1_BLOCK_SIZE, L1_BLOCK_SIZE - 1, L1_BLOCK_SIZE - 1);
            }
        });
    });
}

// --- LEVEL 2: 3D SOMA BLOCKS ---
let scene, camera, renderer;
let l2_grid = [];
const L2_SIZE_X = 5;
const L2_SIZE_Z = 5;
const L2_SIZE_Y = 10;
const L2_GOAL = 3; // Clear 3 planes to win
let l2_piece = null;
let meshGroup = null;
let staticBlocksGroup = null;
let cameraAngle = Math.PI / 4; // 45 deg
let cameraHeight = 14;

// Classic Soma 7 Only
const SOMA_SHAPES = [
    [{x:0,y:0,z:0}, {x:0,y:1,z:0}, {x:1,y:0,z:0}], // V
    [{x:0,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:2,z:0}, {x:1,y:0,z:0}], // L
    [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:2,y:0,z:0}, {x:1,y:1,z:0}], // T
    [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:1,y:1,z:0}, {x:2,y:1,z:0}], // Z
    [{x:0,y:0,z:0}, {x:0,y:1,z:0}, {x:1,y:0,z:0}, {x:1,y:0,z:1}], // A
    [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:1,z:0}, {x:0,y:0,z:1}], // B
    [{x:0,y:0,z:0}, {x:1,y:0,z:0}, {x:0,y:0,z:1}, {x:0,y:1,z:1}]  // P
];

const L2_COLORS = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00, 0xff00ff, 0x00ffff, 0xffaa00];

function advanceToLevel2() {
    currentState = 'LEVEL_TRANSITION';
    cancelAnimationFrame(animationFrameId);
    levelUpOverlay.classList.remove('hidden');
    
    setTimeout(() => {
        levelUpOverlay.classList.add('hidden');
        currentLevel = 2;
        l2_linesCleared = 0;
        
        levelDisplay.innerText = "2 (SOMA)";
        goalText.innerText = `消除 ${L2_GOAL} 層平面`;
        cameraControls.classList.remove('hidden');
        extraControls3D.classList.remove('hidden');
        
        initLevel2();
    }, 2000);
}

function initLevel2() {
    canvasWrapper.innerHTML = '';
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    
    const aspect = canvasWrapper.clientWidth / canvasWrapper.clientHeight;
    camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
    updateCameraPosition();
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(canvasWrapper.clientWidth, canvasWrapper.clientHeight);
    canvasWrapper.appendChild(renderer.domElement);
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);
    
    // Helpers
    const gridHelper = new THREE.GridHelper(L2_SIZE_X, L2_SIZE_X);
    gridHelper.position.set(2, 0, 2);
    scene.add(gridHelper);
    
    const geometry = new THREE.BoxGeometry(L2_SIZE_X, L2_SIZE_Y, L2_SIZE_Z);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x444444 }));
    line.position.set(L2_SIZE_X/2 - 0.5, L2_SIZE_Y/2 - 0.5, L2_SIZE_Z/2 - 0.5);
    scene.add(line);
    
    l2_grid = Array(L2_SIZE_X).fill().map(() => Array(L2_SIZE_Y).fill().map(() => Array(L2_SIZE_Z).fill(0)));
    staticBlocksGroup = new THREE.Group();
    scene.add(staticBlocksGroup);
    
    spawnL2Piece();
    currentState = 'PLAYING';
    dropCounter = 0;
    dropInterval = 800;
    requestAnimationFrame(l2_update);
}

function updateCameraPosition() {
    if (!camera) return;
    const radius = 20;
    const cx = 2.5;
    const cz = 2.5;
    
    camera.position.x = cx + radius * Math.sin(cameraAngle);
    camera.position.z = cz + radius * Math.cos(cameraAngle);
    camera.position.y = cameraHeight;
    camera.lookAt(cx, 5, cz);
}

function rotateCamera(deltaAngle) {
    cameraAngle += deltaAngle;
    updateCameraPosition();
}

function adjustCameraHeight(delta) {
    cameraHeight = Math.max(5, Math.min(30, cameraHeight + delta));
    updateCameraPosition();
}

function spawnL2Piece() {
    const typeIdx = Math.floor(Math.random() * SOMA_SHAPES.length);
    const shapeData = SOMA_SHAPES[typeIdx];
    
    l2_piece = {
        blocks: JSON.parse(JSON.stringify(shapeData)),
        pos: { x: Math.floor(L2_SIZE_X/2), y: L2_SIZE_Y - 1, z: Math.floor(L2_SIZE_Z/2) },
        color: L2_COLORS[typeIdx]
    };
    
    if (meshGroup) scene.remove(meshGroup);
    meshGroup = new THREE.Group();
    
    const mat = new THREE.MeshPhongMaterial({ color: l2_piece.color, flatShading: true });
    const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
    
    l2_piece.blocks.forEach(b => {
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(b.x, b.y, b.z);
        meshGroup.add(mesh);
    });
    
    meshGroup.position.set(l2_piece.pos.x, l2_piece.pos.y, l2_piece.pos.z);
    scene.add(meshGroup);
    
    if (l2_collide(0, 0, 0)) gameOver();
}

function l2_collide(dx, dy, dz, rotatedBlocks = null) {
    const blocks = rotatedBlocks || l2_piece.blocks;
    const px = l2_piece.pos.x + dx;
    const py = l2_piece.pos.y + dy;
    const pz = l2_piece.pos.z + dz;
    
    for (let b of blocks) {
        const x = px + b.x;
        const y = py + b.y;
        const z = pz + b.z;
        if (x < 0 || x >= L2_SIZE_X || y < 0 || z < 0 || z >= L2_SIZE_Z) return true;
        if (y < L2_SIZE_Y && l2_grid[x][y][z]) return true;
    }
    return false;
}

function l2_update(time) {
    if (currentState !== 'PLAYING' || currentLevel !== 2) return;
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    
    if (dropCounter > dropInterval) {
        if (!l2_collide(0, -1, 0)) {
            l2_piece.pos.y--;
            meshGroup.position.y = l2_piece.pos.y;
        } else {
            l2_lock();
        }
        dropCounter = 0;
    }
    renderer.render(scene, camera);
    animationFrameId = requestAnimationFrame(l2_update);
}

function l2_lock() {
    const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
    const mat = new THREE.MeshPhongMaterial({ color: l2_piece.color });
    
    l2_piece.blocks.forEach(b => {
        const x = l2_piece.pos.x + b.x;
        const y = l2_piece.pos.y + b.y;
        const z = l2_piece.pos.z + b.z;
        if (y < L2_SIZE_Y && x >=0 && z >=0 && x < L2_SIZE_X && z < L2_SIZE_Z) {
             l2_grid[x][y][z] = 1;
             const mesh = new THREE.Mesh(geo, mat);
             mesh.position.set(x, y, z);
             staticBlocksGroup.add(mesh);
        }
    });
    scene.remove(meshGroup);
    l2_checkLines();
    if (currentState === 'PLAYING') spawnL2Piece();
}

function l2_checkLines() {
    for (let y = 0; y < L2_SIZE_Y; y++) {
        let full = true;
        for (let x = 0; x < L2_SIZE_X; x++) {
            for (let z = 0; z < L2_SIZE_Z; z++) {
                if (!l2_grid[x][y][z]) { full = false; break; }
            }
            if(!full) break;
        }
        if (full) {
            score += 1000;
            l2_linesCleared++;
            goalText.innerText = `剩餘 ${Math.max(0, L2_GOAL - l2_linesCleared)} 層`;
            scoreDisplay.innerText = score;
            
            // Clear logical grid for this layer
            for (let x = 0; x < L2_SIZE_X; x++) {
                for (let z = 0; z < L2_SIZE_Z; z++) l2_grid[x][y][z] = 0;
            }
            // Rebuild static mesh (Simplification: Visual clear only, no gravity shift in this version)
            scene.remove(staticBlocksGroup);
            staticBlocksGroup = new THREE.Group();
            
            // Re-render surviving blocks
             const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
             const mat = new THREE.MeshPhongMaterial({ color: 0xaaaaaa }); 

             for(let gx=0; gx<L2_SIZE_X; gx++){
                 for(let gy=0; gy<L2_SIZE_Y; gy++){
                     for(let gz=0; gz<L2_SIZE_Z; gz++){
                         if(l2_grid[gx][gy][gz]){
                             const mesh = new THREE.Mesh(geo, mat);
                             mesh.position.set(gx, gy, gz);
                             staticBlocksGroup.add(mesh);
                         }
                     }
                 }
             }
            scene.add(staticBlocksGroup);

            if (l2_linesCleared >= L2_GOAL) {
                gameVictory();
            }
        }
    }
}

function gameVictory() {
    currentState = 'VICTORY';
    cancelAnimationFrame(animationFrameId);
    document.getElementById('victory-score').innerText = score;
    victoryOverlay.classList.remove('hidden');
}

function l2_move(dx, dz) {
    // Camera-relative movement transformation
    // Calculate forward and right vectors based on camera angle
    // Simplified: Snap camera angle to nearest 90 deg quadrant
    const quadrant = Math.round(cameraAngle / (Math.PI/2)) % 4;
    
    let effDx = dx;
    let effDz = dz;

    // Adjust controls based on rotation roughly
    // This is a basic implementation to make controls feel somewhat "relative" to view
    // Ideally we would project, but for grid, quadrant switching is enough.
    // However, to keep muscle memory consistent for the prompt "Left/Right/Up/Down", 
    // let's stick to absolute world coordinates or strict user mental model.
    // If user rotates camera, 'Up' might mean different things.
    // Let's use absolute World Axis for controls to avoid confusion, 
    // OR we just map Arrow Keys to World X/Z.
    // Current implementation: Arrows = World X/Z.
    
    if (!l2_collide(dx, 0, dz)) {
        l2_piece.pos.x += dx;
        l2_piece.pos.z += dz;
        meshGroup.position.set(l2_piece.pos.x, l2_piece.pos.y, l2_piece.pos.z);
    }
}

function l2_rotatePiece() {
    const newBlocks = l2_piece.blocks.map(b => ({ x: b.z, y: b.y, z: -b.x }));
    if (!l2_collide(0, 0, 0, newBlocks)) {
        l2_piece.blocks = newBlocks;
        meshGroup.clear();
        const mat = new THREE.MeshPhongMaterial({ color: l2_piece.color });
        const geo = new THREE.BoxGeometry(0.9, 0.9, 0.9);
        l2_piece.blocks.forEach(b => {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(b.x, b.y, b.z);
            meshGroup.add(mesh);
        });
    }
}

// --- INPUTS ---
document.addEventListener('keydown', (e) => {
    if (currentState !== 'PLAYING') return;
    
    if (currentLevel === 1) {
        if (e.key === 'ArrowLeft') l1_playerMove(-1);
        else if (e.key === 'ArrowRight') l1_playerMove(1);
        else if (e.key === 'ArrowDown') l1_playerDrop();
        else if (e.key === 'ArrowUp') l1_playerRotate();
    } else {
        // 3D Piece Controls
        if (e.key === 'ArrowLeft') l2_move(-1, 0); 
        else if (e.key === 'ArrowRight') l2_move(1, 0); 
        else if (e.key === 'ArrowUp') l2_move(0, -1); 
        else if (e.key === 'ArrowDown') l2_move(0, 1);
        else if (e.code === 'Space') l2_rotatePiece();

        // 3D Camera Controls
        if (e.key.toLowerCase() === 'a') rotateCamera(0.1);
        if (e.key.toLowerCase() === 'd') rotateCamera(-0.1);
        if (e.key.toLowerCase() === 'w') adjustCameraHeight(1);
        if (e.key.toLowerCase() === 's') adjustCameraHeight(-1);
    }
});

// UI Buttons
document.getElementById('start-btn').onclick = () => { startOverlay.classList.add('hidden'); initLevel1(); };
document.getElementById('restart-btn').onclick = restartGame;
document.getElementById('restart-btn-v').onclick = restartGame;

// Camera UI
document.getElementById('cam-left').onclick = () => rotateCamera(0.2);
document.getElementById('cam-right').onclick = () => rotateCamera(-0.2);
document.getElementById('cam-up').onclick = () => adjustCameraHeight(2);
document.getElementById('cam-down').onclick = () => adjustCameraHeight(-2);

function restartGame() {
    currentState = 'MENU';
    currentLevel = 1;
    score = 0;
    l1_board = [];
    l1_piece = null;
    l2_grid = [];
    
    levelDisplay.innerText = "1";
    gameOverOverlay.classList.add('hidden');
    victoryOverlay.classList.add('hidden');
    startOverlay.classList.remove('hidden');
}

// Mobile/Touch
document.getElementById('btn-left').onclick = () => currentLevel === 1 ? l1_playerMove(-1) : l2_move(-1, 0);
document.getElementById('btn-right').onclick = () => currentLevel === 1 ? l1_playerMove(1) : l2_move(1, 0);
document.getElementById('btn-rotate').onclick = () => currentLevel === 1 ? l1_playerRotate() : l2_rotatePiece();
document.getElementById('btn-down').onclick = () => currentLevel === 1 ? l1_playerDrop() : l2_move(0, 1);
document.getElementById('btn-up-key').onclick = () => l2_move(0, -1);
document.getElementById('btn-down-key').onclick = () => l2_move(0, 1);

window.addEventListener('resize', () => {
    if (currentLevel === 2 && renderer) {
        const w = canvasWrapper.clientWidth;
        const h = canvasWrapper.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    }
});
</script>
</body>
</html>